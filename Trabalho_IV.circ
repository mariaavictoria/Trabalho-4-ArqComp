<?xml version="1.0" encoding="UTF-8" standalone="no"?>
<project source="3.4.1" version="1.0">
  This file is intended to be loaded by Logisim-evolution (https://github.com/reds-heig/logisim-evolution).

  <lib desc="#Wiring" name="0">
    <tool name="Splitter">
      <a name="facing" val="south"/>
    </tool>
    <tool name="Pin">
      <a name="appearance" val="NewPins"/>
      <a name="width" val="2"/>
    </tool>
    <tool name="Probe">
      <a name="appearance" val="NewPins"/>
    </tool>
    <tool name="Tunnel">
      <a name="facing" val="east"/>
    </tool>
    <tool name="Clock">
      <a name="facing" val="west"/>
    </tool>
    <tool name="Constant">
      <a name="value" val="0x3"/>
      <a name="width" val="2"/>
    </tool>
  </lib>
  <lib desc="#Gates" name="1">
    <tool name="PLA">
      <a name="table" val=""/>
    </tool>
  </lib>
  <lib desc="#Plexers" name="2">
    <tool name="Multiplexer">
      <a name="enable" val="false"/>
    </tool>
    <tool name="Demultiplexer">
      <a name="enable" val="false"/>
    </tool>
  </lib>
  <lib desc="#Arithmetic" name="3"/>
  <lib desc="#Memory" name="4">
    <tool name="D Flip-Flop">
      <a name="appearance" val="logisim_evolution"/>
    </tool>
    <tool name="T Flip-Flop">
      <a name="appearance" val="logisim_evolution"/>
    </tool>
    <tool name="J-K Flip-Flop">
      <a name="appearance" val="logisim_evolution"/>
    </tool>
    <tool name="S-R Flip-Flop">
      <a name="appearance" val="logisim_evolution"/>
    </tool>
    <tool name="Register">
      <a name="appearance" val="logisim_evolution"/>
    </tool>
    <tool name="Counter">
      <a name="appearance" val="logisim_evolution"/>
    </tool>
    <tool name="Shift Register">
      <a name="appearance" val="logisim_evolution"/>
    </tool>
    <tool name="Random">
      <a name="appearance" val="logisim_evolution"/>
    </tool>
    <tool name="RAM">
      <a name="appearance" val="logisim_evolution"/>
    </tool>
    <tool name="ROM">
      <a name="appearance" val="logisim_evolution"/>
      <a name="contents">addr/data: 8 8
0
</a>
    </tool>
  </lib>
  <lib desc="#I/O" name="5"/>
  <lib desc="#TTL" name="6"/>
  <lib desc="#TCL" name="7">
    <tool name="TclGeneric">
      <a name="content">library ieee;&#13;
use ieee.std_logic_1164.all;&#13;
&#13;
entity TCL_Generic is&#13;
  port(&#13;
    --Insert input ports below&#13;
    horloge_i  : in  std_logic;                    -- input bit example&#13;
    val_i      : in  std_logic_vector(3 downto 0); -- input vector example&#13;
&#13;
	  --Insert output ports below&#13;
    max_o      : out std_logic;                    -- output bit example&#13;
    cpt_o      : out std_logic_Vector(3 downto 0)  -- output vector example&#13;
  );&#13;
end TCL_Generic;&#13;
</a>
    </tool>
  </lib>
  <lib desc="#Base" name="8">
    <tool name="Text Tool">
      <a name="font" val="SansSerif plain 12"/>
      <a name="halign" val="center"/>
      <a name="text" val=""/>
      <a name="valign" val="base"/>
    </tool>
  </lib>
  <lib desc="#BFH-Praktika" name="9"/>
  <lib desc="#Input/Output-Extra" name="10"/>
  <lib desc="#Soc" name="11">
    <tool name="Rv32im">
      <a name="SocBusSelection" val=""/>
    </tool>
    <tool name="Nios2">
      <a name="SocBusSelection" val=""/>
    </tool>
    <tool name="SocBus">
      <a name="SocBusIdentifier" val="0x000001908EF866D65f5a544a"/>
    </tool>
    <tool name="Socmem">
      <a name="SocBusSelection" val=""/>
    </tool>
    <tool name="SocPio">
      <a name="SocBusSelection" val=""/>
    </tool>
    <tool name="SocVga">
      <a name="SocBusSelection" val=""/>
    </tool>
    <tool name="SocJtagUart">
      <a name="SocBusSelection" val=""/>
    </tool>
  </lib>
  <main name="main"/>
  <options>
    <a name="gateUndefined" val="ignore"/>
    <a name="simlimit" val="1000"/>
    <a name="simrand" val="0"/>
  </options>
  <mappings>
    <tool lib="8" map="Button2" name="Menu Tool"/>
    <tool lib="8" map="Button3" name="Menu Tool"/>
    <tool lib="8" map="Ctrl Button1" name="Menu Tool"/>
  </mappings>
  <toolbar>
    <tool lib="8" name="Poke Tool"/>
    <tool lib="8" name="Edit Tool"/>
    <tool lib="8" name="Wiring Tool"/>
    <tool lib="8" name="Text Tool">
      <a name="font" val="SansSerif plain 12"/>
      <a name="halign" val="center"/>
      <a name="text" val=""/>
      <a name="valign" val="base"/>
    </tool>
    <sep/>
    <tool lib="0" name="Pin">
      <a name="appearance" val="NewPins"/>
    </tool>
    <tool lib="0" name="Pin">
      <a name="appearance" val="NewPins"/>
      <a name="facing" val="west"/>
      <a name="output" val="true"/>
    </tool>
    <sep/>
    <tool lib="1" name="NOT Gate"/>
    <tool lib="1" name="AND Gate"/>
    <tool lib="1" name="OR Gate"/>
    <tool lib="1" name="XOR Gate"/>
    <tool lib="1" name="NAND Gate"/>
    <tool lib="1" name="NOR Gate"/>
    <sep/>
    <tool lib="4" name="D Flip-Flop">
      <a name="appearance" val="logisim_evolution"/>
    </tool>
    <tool lib="4" name="Register">
      <a name="appearance" val="logisim_evolution"/>
    </tool>
  </toolbar>
  <circuit name="main">
    <a name="appearance" val="logisim_evolution"/>
    <a name="circuit" val="main"/>
    <a name="circuitnamedboxfixedsize" val="true"/>
    <a name="circuitvhdlpath" val=""/>
    <a name="clabel" val=""/>
    <a name="clabelfont" val="SansSerif bold 16"/>
    <a name="clabelup" val="east"/>
    <comp lib="0" loc="(250,270)" name="Clock"/>
    <comp lib="0" loc="(2580,570)" name="Constant">
      <a name="width" val="32"/>
    </comp>
    <comp lib="0" loc="(290,370)" name="Pin">
      <a name="appearance" val="NewPins"/>
    </comp>
    <comp lib="0" loc="(3760,760)" name="Splitter">
      <a name="fanout" val="32"/>
      <a name="incoming" val="32"/>
    </comp>
    <comp lib="0" loc="(3810,430)" name="Splitter">
      <a name="facing" val="west"/>
      <a name="fanout" val="24"/>
      <a name="incoming" val="24"/>
    </comp>
    <comp lib="0" loc="(750,660)" name="Splitter">
      <a name="fanout" val="32"/>
      <a name="incoming" val="32"/>
    </comp>
    <comp lib="0" loc="(790,330)" name="Splitter">
      <a name="facing" val="west"/>
      <a name="fanout" val="24"/>
      <a name="incoming" val="24"/>
    </comp>
    <comp lib="1" loc="(1340,720)" name="NOT Gate">
      <a name="facing" val="west"/>
    </comp>
    <comp lib="1" loc="(2430,80)" name="NOT Gate"/>
    <comp lib="1" loc="(2520,100)" name="AND Gate"/>
    <comp lib="1" loc="(3130,670)" name="AND Gate"/>
    <comp lib="1" loc="(3510,210)" name="AND Gate"/>
    <comp lib="1" loc="(3600,210)" name="OR Gate"/>
    <comp lib="2" loc="(2490,540)" name="Multiplexer">
      <a name="enable" val="false"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="2" loc="(2560,400)" name="Multiplexer">
      <a name="enable" val="false"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="2" loc="(2590,220)" name="Multiplexer">
      <a name="enable" val="false"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="2" loc="(2590,470)" name="Multiplexer">
      <a name="enable" val="false"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="2" loc="(2790,530)" name="Multiplexer">
      <a name="enable" val="false"/>
      <a name="facing" val="north"/>
      <a name="select" val="2"/>
      <a name="selloc" val="tr"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="2" loc="(2880,530)" name="Multiplexer">
      <a name="enable" val="false"/>
      <a name="facing" val="north"/>
      <a name="select" val="2"/>
      <a name="selloc" val="tr"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="2" loc="(340,420)" name="Multiplexer">
      <a name="enable" val="false"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="2" loc="(4690,300)" name="Multiplexer">
      <a name="enable" val="false"/>
      <a name="selloc" val="tr"/>
      <a name="width" val="32"/>
    </comp>
    <comp lib="4" loc="(3900,410)" name="RAM">
      <a name="addrWidth" val="24"/>
      <a name="appearance" val="logisim_evolution"/>
      <a name="dataWidth" val="32"/>
    </comp>
    <comp lib="4" loc="(810,320)" name="ROM">
      <a name="addrWidth" val="24"/>
      <a name="appearance" val="logisim_evolution"/>
      <a name="contents">addr/data: 24 32
0
</a>
      <a name="dataWidth" val="32"/>
    </comp>
    <comp loc="(1390,330)" name="IFID">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <comp loc="(1800,20)" name="Control_Unit">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <comp loc="(1800,390)" name="RegisterFile">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <comp loc="(1810,670)" name="ImmGen">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <comp loc="(1820,890)" name="Hazard">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <comp loc="(2310,330)" name="IDEX">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <comp loc="(2670,620)" name="ALU_Control">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <comp loc="(2920,220)" name="Somador">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <comp loc="(2990,390)" name="ALU">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <comp loc="(3000,900)" name="Forward">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <comp loc="(3380,290)" name="EXMEM">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <comp loc="(4480,250)" name="MEMWB">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <comp loc="(660,350)" name="PC4">
      <a name="appearance" val="logisim_evolution"/>
    </comp>
    <wire from="(1050,380)" to="(1060,380)"/>
    <wire from="(1060,380)" to="(1060,410)"/>
    <wire from="(1060,410)" to="(1170,410)"/>
    <wire from="(1070,270)" to="(1070,350)"/>
    <wire from="(1070,350)" to="(1170,350)"/>
    <wire from="(1090,290)" to="(1090,390)"/>
    <wire from="(1090,390)" to="(1150,390)"/>
    <wire from="(1110,200)" to="(1110,850)"/>
    <wire from="(1110,850)" to="(3610,850)"/>
    <wire from="(1130,230)" to="(1130,770)"/>
    <wire from="(1130,770)" to="(1480,770)"/>
    <wire from="(1150,390)" to="(1150,720)"/>
    <wire from="(1150,390)" to="(1170,390)"/>
    <wire from="(1150,720)" to="(1340,720)"/>
    <wire from="(1160,250)" to="(1160,330)"/>
    <wire from="(1160,250)" to="(1480,250)"/>
    <wire from="(1160,330)" to="(1170,330)"/>
    <wire from="(1370,720)" to="(1400,720)"/>
    <wire from="(1380,390)" to="(1390,390)"/>
    <wire from="(1390,330)" to="(1410,330)"/>
    <wire from="(1390,370)" to="(1450,370)"/>
    <wire from="(1390,390)" to="(1430,390)"/>
    <wire from="(1390,410)" to="(1440,410)"/>
    <wire from="(1390,430)" to="(1420,430)"/>
    <wire from="(1400,1030)" to="(1860,1030)"/>
    <wire from="(1400,510)" to="(1400,720)"/>
    <wire from="(1400,510)" to="(1470,510)"/>
    <wire from="(1400,720)" to="(1400,1030)"/>
    <wire from="(1410,330)" to="(1410,340)"/>
    <wire from="(1410,340)" to="(2020,340)"/>
    <wire from="(1420,430)" to="(1420,630)"/>
    <wire from="(1420,630)" to="(2090,630)"/>
    <wire from="(1430,390)" to="(1430,950)"/>
    <wire from="(1430,390)" to="(1540,390)"/>
    <wire from="(1430,950)" to="(1600,950)"/>
    <wire from="(1440,410)" to="(1440,970)"/>
    <wire from="(1440,410)" to="(1510,410)"/>
    <wire from="(1440,970)" to="(1600,970)"/>
    <wire from="(1450,20)" to="(1450,370)"/>
    <wire from="(1450,20)" to="(1580,20)"/>
    <wire from="(1450,370)" to="(1450,670)"/>
    <wire from="(1450,670)" to="(1590,670)"/>
    <wire from="(1470,50)" to="(1470,510)"/>
    <wire from="(1470,50)" to="(1580,50)"/>
    <wire from="(1480,250)" to="(1480,330)"/>
    <wire from="(1480,330)" to="(1480,490)"/>
    <wire from="(1480,330)" to="(2070,330)"/>
    <wire from="(1480,490)" to="(1530,490)"/>
    <wire from="(1480,770)" to="(1480,810)"/>
    <wire from="(1480,810)" to="(3400,810)"/>
    <wire from="(1500,450)" to="(1500,790)"/>
    <wire from="(1500,450)" to="(1580,450)"/>
    <wire from="(1500,790)" to="(2780,790)"/>
    <wire from="(1510,410)" to="(1510,710)"/>
    <wire from="(1510,410)" to="(1580,410)"/>
    <wire from="(1510,710)" to="(2090,710)"/>
    <wire from="(1530,490)" to="(1530,890)"/>
    <wire from="(1530,490)" to="(1580,490)"/>
    <wire from="(1530,890)" to="(1600,890)"/>
    <wire from="(1540,390)" to="(1540,610)"/>
    <wire from="(1540,390)" to="(1580,390)"/>
    <wire from="(1540,610)" to="(1820,610)"/>
    <wire from="(1550,310)" to="(1550,470)"/>
    <wire from="(1550,310)" to="(2020,310)"/>
    <wire from="(1550,470)" to="(1580,470)"/>
    <wire from="(1560,430)" to="(1560,830)"/>
    <wire from="(1560,430)" to="(1580,430)"/>
    <wire from="(1560,830)" to="(2630,830)"/>
    <wire from="(1570,840)" to="(1570,910)"/>
    <wire from="(1570,840)" to="(2700,840)"/>
    <wire from="(1570,910)" to="(1600,910)"/>
    <wire from="(1580,40)" to="(1580,50)"/>
    <wire from="(1590,860)" to="(1590,930)"/>
    <wire from="(1590,860)" to="(2410,860)"/>
    <wire from="(1590,930)" to="(1600,930)"/>
    <wire from="(1790,40)" to="(1800,40)"/>
    <wire from="(1800,100)" to="(1890,100)"/>
    <wire from="(1800,120)" to="(1950,120)"/>
    <wire from="(1800,140)" to="(1980,140)"/>
    <wire from="(1800,160)" to="(2040,160)"/>
    <wire from="(1800,180)" to="(2000,180)"/>
    <wire from="(1800,20)" to="(1930,20)"/>
    <wire from="(1800,200)" to="(2060,200)"/>
    <wire from="(1800,220)" to="(1810,220)"/>
    <wire from="(1800,240)" to="(1830,240)"/>
    <wire from="(1800,260)" to="(1960,260)"/>
    <wire from="(1800,280)" to="(1970,280)"/>
    <wire from="(1800,390)" to="(1830,390)"/>
    <wire from="(1800,40)" to="(1870,40)"/>
    <wire from="(1800,410)" to="(1810,410)"/>
    <wire from="(1800,60)" to="(1910,60)"/>
    <wire from="(1800,80)" to="(1850,80)"/>
    <wire from="(1810,220)" to="(1810,370)"/>
    <wire from="(1810,370)" to="(1930,370)"/>
    <wire from="(1810,410)" to="(1810,590)"/>
    <wire from="(1810,590)" to="(2090,590)"/>
    <wire from="(1810,670)" to="(1860,670)"/>
    <wire from="(1820,610)" to="(1820,690)"/>
    <wire from="(1820,690)" to="(2090,690)"/>
    <wire from="(1820,890)" to="(1860,890)"/>
    <wire from="(1830,240)" to="(1830,360)"/>
    <wire from="(1830,360)" to="(1990,360)"/>
    <wire from="(1830,390)" to="(1830,570)"/>
    <wire from="(1830,570)" to="(2090,570)"/>
    <wire from="(1850,510)" to="(2090,510)"/>
    <wire from="(1850,80)" to="(1850,510)"/>
    <wire from="(1860,610)" to="(1860,670)"/>
    <wire from="(1860,610)" to="(2090,610)"/>
    <wire from="(1860,890)" to="(1860,1030)"/>
    <wire from="(1870,40)" to="(1870,530)"/>
    <wire from="(1870,530)" to="(2090,530)"/>
    <wire from="(1890,100)" to="(1890,490)"/>
    <wire from="(1890,490)" to="(2090,490)"/>
    <wire from="(190,230)" to="(1130,230)"/>
    <wire from="(190,230)" to="(190,430)"/>
    <wire from="(190,430)" to="(310,430)"/>
    <wire from="(1910,550)" to="(2090,550)"/>
    <wire from="(1910,60)" to="(1910,550)"/>
    <wire from="(1930,20)" to="(1930,350)"/>
    <wire from="(1930,350)" to="(2090,350)"/>
    <wire from="(1930,370)" to="(1930,650)"/>
    <wire from="(1930,650)" to="(2090,650)"/>
    <wire from="(1950,120)" to="(1950,470)"/>
    <wire from="(1950,470)" to="(2090,470)"/>
    <wire from="(1960,260)" to="(1960,730)"/>
    <wire from="(1960,730)" to="(2090,730)"/>
    <wire from="(1970,280)" to="(1970,750)"/>
    <wire from="(1970,750)" to="(2090,750)"/>
    <wire from="(1980,140)" to="(1980,450)"/>
    <wire from="(1980,450)" to="(2090,450)"/>
    <wire from="(1990,360)" to="(1990,670)"/>
    <wire from="(1990,670)" to="(2090,670)"/>
    <wire from="(2000,180)" to="(2000,410)"/>
    <wire from="(2000,410)" to="(2090,410)"/>
    <wire from="(2020,260)" to="(2020,310)"/>
    <wire from="(2020,260)" to="(2180,260)"/>
    <wire from="(2020,340)" to="(2020,430)"/>
    <wire from="(2020,430)" to="(2090,430)"/>
    <wire from="(2040,160)" to="(2040,370)"/>
    <wire from="(2040,370)" to="(2090,370)"/>
    <wire from="(2060,200)" to="(2060,390)"/>
    <wire from="(2060,390)" to="(2090,390)"/>
    <wire from="(2070,290)" to="(2070,330)"/>
    <wire from="(2070,290)" to="(2730,290)"/>
    <wire from="(2070,330)" to="(2090,330)"/>
    <wire from="(2090,670)" to="(2100,670)"/>
    <wire from="(2180,20)" to="(2180,260)"/>
    <wire from="(2180,20)" to="(4480,20)"/>
    <wire from="(2310,330)" to="(2320,330)"/>
    <wire from="(2310,350)" to="(2330,350)"/>
    <wire from="(2310,370)" to="(2380,370)"/>
    <wire from="(2310,390)" to="(2360,390)"/>
    <wire from="(2310,410)" to="(2400,410)"/>
    <wire from="(2310,430)" to="(2460,430)"/>
    <wire from="(2310,450)" to="(2410,450)"/>
    <wire from="(2310,470)" to="(2340,470)"/>
    <wire from="(2310,490)" to="(2320,490)"/>
    <wire from="(2310,510)" to="(2340,510)"/>
    <wire from="(2310,530)" to="(2320,530)"/>
    <wire from="(2310,550)" to="(2430,550)"/>
    <wire from="(2310,570)" to="(2340,570)"/>
    <wire from="(2310,590)" to="(2440,590)"/>
    <wire from="(2310,600)" to="(2310,610)"/>
    <wire from="(2310,600)" to="(2410,600)"/>
    <wire from="(2310,630)" to="(2360,630)"/>
    <wire from="(2310,650)" to="(2400,650)"/>
    <wire from="(2310,670)" to="(2380,670)"/>
    <wire from="(2310,690)" to="(2360,690)"/>
    <wire from="(2310,710)" to="(2450,710)"/>
    <wire from="(2310,730)" to="(2430,730)"/>
    <wire from="(2320,330)" to="(2370,330)"/>
    <wire from="(2320,480)" to="(2320,490)"/>
    <wire from="(2320,480)" to="(2350,480)"/>
    <wire from="(2320,520)" to="(2320,530)"/>
    <wire from="(2320,520)" to="(2350,520)"/>
    <wire from="(2320,80)" to="(2320,330)"/>
    <wire from="(2320,80)" to="(2400,80)"/>
    <wire from="(2330,350)" to="(2330,680)"/>
    <wire from="(2330,680)" to="(2450,680)"/>
    <wire from="(2340,340)" to="(2340,470)"/>
    <wire from="(2340,340)" to="(3140,340)"/>
    <wire from="(2340,490)" to="(2340,510)"/>
    <wire from="(2340,490)" to="(2390,490)"/>
    <wire from="(2340,530)" to="(2340,570)"/>
    <wire from="(2340,530)" to="(2440,530)"/>
    <wire from="(2350,350)" to="(2350,480)"/>
    <wire from="(2350,350)" to="(2700,350)"/>
    <wire from="(2350,510)" to="(2350,520)"/>
    <wire from="(2350,510)" to="(2410,510)"/>
    <wire from="(2360,390)" to="(2360,620)"/>
    <wire from="(2360,620)" to="(2450,620)"/>
    <wire from="(2360,630)" to="(2360,660)"/>
    <wire from="(2360,660)" to="(2450,660)"/>
    <wire from="(2360,690)" to="(2360,980)"/>
    <wire from="(2360,980)" to="(2780,980)"/>
    <wire from="(2370,330)" to="(2370,570)"/>
    <wire from="(2370,570)" to="(2470,570)"/>
    <wire from="(2380,370)" to="(2380,640)"/>
    <wire from="(2380,640)" to="(2450,640)"/>
    <wire from="(2380,670)" to="(2380,960)"/>
    <wire from="(2380,960)" to="(2780,960)"/>
    <wire from="(2390,460)" to="(2390,490)"/>
    <wire from="(2390,460)" to="(2470,460)"/>
    <wire from="(2400,210)" to="(2400,410)"/>
    <wire from="(2400,210)" to="(2560,210)"/>
    <wire from="(2400,410)" to="(2530,410)"/>
    <wire from="(2400,470)" to="(2400,650)"/>
    <wire from="(2400,470)" to="(2480,470)"/>
    <wire from="(2410,310)" to="(2410,450)"/>
    <wire from="(2410,310)" to="(3160,310)"/>
    <wire from="(2410,500)" to="(2410,510)"/>
    <wire from="(2410,500)" to="(2500,500)"/>
    <wire from="(2410,600)" to="(2410,860)"/>
    <wire from="(2410,600)" to="(2720,600)"/>
    <wire from="(2430,230)" to="(2430,390)"/>
    <wire from="(2430,230)" to="(2560,230)"/>
    <wire from="(2430,390)" to="(2430,550)"/>
    <wire from="(2430,390)" to="(2530,390)"/>
    <wire from="(2430,730)" to="(2430,760)"/>
    <wire from="(2430,760)" to="(2740,760)"/>
    <wire from="(2430,80)" to="(2470,80)"/>
    <wire from="(2440,510)" to="(2440,530)"/>
    <wire from="(2440,510)" to="(2590,510)"/>
    <wire from="(2440,530)" to="(2460,530)"/>
    <wire from="(2440,550)" to="(2440,590)"/>
    <wire from="(2440,550)" to="(2460,550)"/>
    <wire from="(2440,590)" to="(2610,590)"/>
    <wire from="(2450,710)" to="(2450,730)"/>
    <wire from="(2450,730)" to="(2690,730)"/>
    <wire from="(2460,120)" to="(2460,430)"/>
    <wire from="(2460,120)" to="(2470,120)"/>
    <wire from="(2460,430)" to="(2540,430)"/>
    <wire from="(2470,450)" to="(2470,460)"/>
    <wire from="(2470,450)" to="(2490,450)"/>
    <wire from="(2470,560)" to="(2470,570)"/>
    <wire from="(2480,260)" to="(2480,470)"/>
    <wire from="(2480,260)" to="(2570,260)"/>
    <wire from="(2490,370)" to="(2490,450)"/>
    <wire from="(2490,370)" to="(3160,370)"/>
    <wire from="(2490,540)" to="(2510,540)"/>
    <wire from="(250,270)" to="(320,270)"/>
    <wire from="(2500,450)" to="(2500,500)"/>
    <wire from="(2500,450)" to="(2550,450)"/>
    <wire from="(2510,460)" to="(2510,540)"/>
    <wire from="(2510,460)" to="(2560,460)"/>
    <wire from="(2520,100)" to="(2550,100)"/>
    <wire from="(2520,150)" to="(2520,500)"/>
    <wire from="(2520,150)" to="(2550,150)"/>
    <wire from="(2520,500)" to="(2570,500)"/>
    <wire from="(2540,420)" to="(2540,430)"/>
    <wire from="(2550,100)" to="(2550,150)"/>
    <wire from="(2550,100)" to="(3060,100)"/>
    <wire from="(2550,440)" to="(2550,450)"/>
    <wire from="(2550,440)" to="(2620,440)"/>
    <wire from="(2550,480)" to="(2550,540)"/>
    <wire from="(2550,480)" to="(2560,480)"/>
    <wire from="(2550,540)" to="(2590,540)"/>
    <wire from="(2560,400)" to="(2640,400)"/>
    <wire from="(2570,240)" to="(2570,260)"/>
    <wire from="(2570,490)" to="(2570,500)"/>
    <wire from="(2580,570)" to="(2590,570)"/>
    <wire from="(2590,220)" to="(2700,220)"/>
    <wire from="(2590,470)" to="(2630,470)"/>
    <wire from="(2590,510)" to="(2590,530)"/>
    <wire from="(2590,530)" to="(2710,530)"/>
    <wire from="(2590,540)" to="(2590,570)"/>
    <wire from="(2610,240)" to="(2610,590)"/>
    <wire from="(2610,240)" to="(2700,240)"/>
    <wire from="(2620,360)" to="(2620,440)"/>
    <wire from="(2620,360)" to="(3140,360)"/>
    <wire from="(2630,1000)" to="(2780,1000)"/>
    <wire from="(2630,470)" to="(2630,590)"/>
    <wire from="(2630,590)" to="(2860,590)"/>
    <wire from="(2630,750)" to="(2630,830)"/>
    <wire from="(2630,750)" to="(3660,750)"/>
    <wire from="(2630,830)" to="(2630,1000)"/>
    <wire from="(2640,400)" to="(2640,580)"/>
    <wire from="(2640,580)" to="(2770,580)"/>
    <wire from="(2670,620)" to="(2680,620)"/>
    <wire from="(2670,640)" to="(2670,690)"/>
    <wire from="(2670,690)" to="(3080,690)"/>
    <wire from="(2670,880)" to="(2670,920)"/>
    <wire from="(2670,880)" to="(3690,880)"/>
    <wire from="(2670,920)" to="(2780,920)"/>
    <wire from="(2680,430)" to="(2680,620)"/>
    <wire from="(2680,430)" to="(2770,430)"/>
    <wire from="(2690,450)" to="(2690,730)"/>
    <wire from="(2690,450)" to="(2770,450)"/>
    <wire from="(2700,350)" to="(2700,840)"/>
    <wire from="(2700,350)" to="(3160,350)"/>
    <wire from="(2710,1020)" to="(2780,1020)"/>
    <wire from="(2710,530)" to="(2710,540)"/>
    <wire from="(2710,540)" to="(2750,540)"/>
    <wire from="(2710,730)" to="(2710,1020)"/>
    <wire from="(2710,730)" to="(3500,730)"/>
    <wire from="(2720,390)" to="(2720,510)"/>
    <wire from="(2720,390)" to="(2770,390)"/>
    <wire from="(2720,510)" to="(2790,510)"/>
    <wire from="(2720,600)" to="(2720,680)"/>
    <wire from="(2720,680)" to="(3060,680)"/>
    <wire from="(2730,290)" to="(2730,900)"/>
    <wire from="(2730,290)" to="(3130,290)"/>
    <wire from="(2730,900)" to="(2780,900)"/>
    <wire from="(2740,470)" to="(2740,760)"/>
    <wire from="(2740,470)" to="(2770,470)"/>
    <wire from="(2750,410)" to="(2750,520)"/>
    <wire from="(2750,410)" to="(2770,410)"/>
    <wire from="(2750,520)" to="(2880,520)"/>
    <wire from="(2750,540)" to="(2750,610)"/>
    <wire from="(2750,610)" to="(3030,610)"/>
    <wire from="(2760,870)" to="(2760,940)"/>
    <wire from="(2760,870)" to="(3450,870)"/>
    <wire from="(2760,940)" to="(2780,940)"/>
    <wire from="(2770,570)" to="(2770,580)"/>
    <wire from="(2780,570)" to="(2780,790)"/>
    <wire from="(2780,790)" to="(2870,790)"/>
    <wire from="(2780,900)" to="(2790,900)"/>
    <wire from="(2790,510)" to="(2790,530)"/>
    <wire from="(2790,570)" to="(2790,700)"/>
    <wire from="(2790,700)" to="(2880,700)"/>
    <wire from="(280,410)" to="(280,530)"/>
    <wire from="(280,410)" to="(310,410)"/>
    <wire from="(280,530)" to="(730,530)"/>
    <wire from="(2810,550)" to="(2830,550)"/>
    <wire from="(2830,550)" to="(2830,710)"/>
    <wire from="(2830,710)" to="(3000,710)"/>
    <wire from="(2860,570)" to="(2860,590)"/>
    <wire from="(2870,570)" to="(2870,790)"/>
    <wire from="(2870,790)" to="(3630,790)"/>
    <wire from="(2880,520)" to="(2880,530)"/>
    <wire from="(2880,570)" to="(2880,700)"/>
    <wire from="(2880,700)" to="(3430,700)"/>
    <wire from="(290,370)" to="(440,370)"/>
    <wire from="(2900,550)" to="(2930,550)"/>
    <wire from="(2920,220)" to="(3030,220)"/>
    <wire from="(2930,550)" to="(2930,660)"/>
    <wire from="(2930,660)" to="(3020,660)"/>
    <wire from="(2990,390)" to="(3010,390)"/>
    <wire from="(2990,410)" to="(2990,450)"/>
    <wire from="(2990,450)" to="(3020,450)"/>
    <wire from="(2990,520)" to="(2990,650)"/>
    <wire from="(2990,520)" to="(3020,520)"/>
    <wire from="(2990,650)" to="(3080,650)"/>
    <wire from="(3000,710)" to="(3000,900)"/>
    <wire from="(3000,920)" to="(3020,920)"/>
    <wire from="(3010,390)" to="(3010,430)"/>
    <wire from="(3010,430)" to="(3090,430)"/>
    <wire from="(3020,450)" to="(3020,520)"/>
    <wire from="(3020,660)" to="(3020,920)"/>
    <wire from="(3030,220)" to="(3030,410)"/>
    <wire from="(3030,410)" to="(3160,410)"/>
    <wire from="(3030,470)" to="(3030,610)"/>
    <wire from="(3030,470)" to="(3160,470)"/>
    <wire from="(3060,100)" to="(3060,510)"/>
    <wire from="(3060,510)" to="(3160,510)"/>
    <wire from="(3060,630)" to="(3060,680)"/>
    <wire from="(3060,630)" to="(3140,630)"/>
    <wire from="(3090,430)" to="(3090,450)"/>
    <wire from="(3090,450)" to="(3160,450)"/>
    <wire from="(3130,250)" to="(3130,290)"/>
    <wire from="(3130,250)" to="(3880,250)"/>
    <wire from="(3130,290)" to="(3160,290)"/>
    <wire from="(3130,430)" to="(3130,640)"/>
    <wire from="(3130,430)" to="(3160,430)"/>
    <wire from="(3130,640)" to="(3140,640)"/>
    <wire from="(3130,670)" to="(3140,670)"/>
    <wire from="(3140,330)" to="(3140,340)"/>
    <wire from="(3140,330)" to="(3160,330)"/>
    <wire from="(3140,360)" to="(3140,390)"/>
    <wire from="(3140,390)" to="(3160,390)"/>
    <wire from="(3140,490)" to="(3140,630)"/>
    <wire from="(3140,490)" to="(3160,490)"/>
    <wire from="(3140,640)" to="(3140,670)"/>
    <wire from="(320,250)" to="(1160,250)"/>
    <wire from="(320,250)" to="(320,270)"/>
    <wire from="(320,270)" to="(320,350)"/>
    <wire from="(320,350)" to="(440,350)"/>
    <wire from="(320,440)" to="(320,480)"/>
    <wire from="(320,480)" to="(680,480)"/>
    <wire from="(3380,290)" to="(3390,290)"/>
    <wire from="(3380,310)" to="(3850,310)"/>
    <wire from="(3380,330)" to="(3830,330)"/>
    <wire from="(3380,350)" to="(3450,350)"/>
    <wire from="(3380,370)" to="(4240,370)"/>
    <wire from="(3380,390)" to="(3400,390)"/>
    <wire from="(3380,410)" to="(3420,410)"/>
    <wire from="(3380,430)" to="(3430,430)"/>
    <wire from="(3380,450)" to="(3730,450)"/>
    <wire from="(3380,470)" to="(3500,470)"/>
    <wire from="(3380,490)" to="(3550,490)"/>
    <wire from="(3390,190)" to="(3390,290)"/>
    <wire from="(3390,190)" to="(3460,190)"/>
    <wire from="(340,420)" to="(420,420)"/>
    <wire from="(3400,390)" to="(3400,810)"/>
    <wire from="(3420,230)" to="(3420,410)"/>
    <wire from="(3420,230)" to="(3460,230)"/>
    <wire from="(3430,430)" to="(3430,700)"/>
    <wire from="(3430,430)" to="(3730,430)"/>
    <wire from="(3450,350)" to="(3450,870)"/>
    <wire from="(3450,350)" to="(4200,350)"/>
    <wire from="(3500,470)" to="(3500,730)"/>
    <wire from="(3500,470)" to="(3710,470)"/>
    <wire from="(3510,210)" to="(3540,210)"/>
    <wire from="(3540,190)" to="(3540,210)"/>
    <wire from="(3540,190)" to="(3550,190)"/>
    <wire from="(3550,230)" to="(3550,490)"/>
    <wire from="(3600,210)" to="(3610,210)"/>
    <wire from="(3610,210)" to="(3610,850)"/>
    <wire from="(3630,290)" to="(3630,790)"/>
    <wire from="(3630,290)" to="(4140,290)"/>
    <wire from="(3660,320)" to="(3660,750)"/>
    <wire from="(3660,320)" to="(4170,320)"/>
    <wire from="(3690,170)" to="(3690,880)"/>
    <wire from="(3690,170)" to="(4480,170)"/>
    <wire from="(3710,390)" to="(3710,470)"/>
    <wire from="(3710,390)" to="(4250,390)"/>
    <wire from="(3730,400)" to="(3730,430)"/>
    <wire from="(3730,400)" to="(4210,400)"/>
    <wire from="(3730,430)" to="(3750,430)"/>
    <wire from="(3730,450)" to="(3730,790)"/>
    <wire from="(3730,790)" to="(3880,790)"/>
    <wire from="(3750,430)" to="(3750,760)"/>
    <wire from="(3750,760)" to="(3760,760)"/>
    <wire from="(3780,440)" to="(3790,440)"/>
    <wire from="(3780,450)" to="(3790,450)"/>
    <wire from="(3780,460)" to="(3790,460)"/>
    <wire from="(3780,470)" to="(3790,470)"/>
    <wire from="(3780,480)" to="(3790,480)"/>
    <wire from="(3780,490)" to="(3790,490)"/>
    <wire from="(3780,500)" to="(3790,500)"/>
    <wire from="(3780,510)" to="(3790,510)"/>
    <wire from="(3780,520)" to="(3790,520)"/>
    <wire from="(3780,530)" to="(3790,530)"/>
    <wire from="(3780,540)" to="(3790,540)"/>
    <wire from="(3780,550)" to="(3790,550)"/>
    <wire from="(3780,560)" to="(3790,560)"/>
    <wire from="(3780,570)" to="(3790,570)"/>
    <wire from="(3780,580)" to="(3790,580)"/>
    <wire from="(3780,590)" to="(3790,590)"/>
    <wire from="(3780,600)" to="(3790,600)"/>
    <wire from="(3780,610)" to="(3790,610)"/>
    <wire from="(3780,620)" to="(3790,620)"/>
    <wire from="(3780,630)" to="(3790,630)"/>
    <wire from="(3780,640)" to="(3790,640)"/>
    <wire from="(3780,650)" to="(3790,650)"/>
    <wire from="(3780,660)" to="(3790,660)"/>
    <wire from="(3780,670)" to="(3790,670)"/>
    <wire from="(380,290)" to="(1090,290)"/>
    <wire from="(380,290)" to="(380,410)"/>
    <wire from="(380,410)" to="(440,410)"/>
    <wire from="(3810,420)" to="(3810,430)"/>
    <wire from="(3810,420)" to="(3900,420)"/>
    <wire from="(3830,330)" to="(3830,470)"/>
    <wire from="(3830,470)" to="(3900,470)"/>
    <wire from="(3850,310)" to="(3850,460)"/>
    <wire from="(3850,460)" to="(3900,460)"/>
    <wire from="(3880,250)" to="(3880,480)"/>
    <wire from="(3880,250)" to="(4260,250)"/>
    <wire from="(3880,480)" to="(3900,480)"/>
    <wire from="(3880,500)" to="(3880,790)"/>
    <wire from="(3880,500)" to="(3900,500)"/>
    <wire from="(4140,290)" to="(4140,470)"/>
    <wire from="(4140,470)" to="(4710,470)"/>
    <wire from="(4140,500)" to="(4230,500)"/>
    <wire from="(4170,320)" to="(4170,450)"/>
    <wire from="(4170,450)" to="(4500,450)"/>
    <wire from="(420,390)" to="(420,420)"/>
    <wire from="(420,390)" to="(440,390)"/>
    <wire from="(4200,270)" to="(4200,350)"/>
    <wire from="(4200,270)" to="(4260,270)"/>
    <wire from="(4210,330)" to="(4210,400)"/>
    <wire from="(4210,330)" to="(4260,330)"/>
    <wire from="(4230,310)" to="(4230,500)"/>
    <wire from="(4230,310)" to="(4260,310)"/>
    <wire from="(4240,290)" to="(4240,370)"/>
    <wire from="(4240,290)" to="(4260,290)"/>
    <wire from="(4250,350)" to="(4250,390)"/>
    <wire from="(4250,350)" to="(4260,350)"/>
    <wire from="(4480,170)" to="(4480,250)"/>
    <wire from="(4480,20)" to="(4480,170)"/>
    <wire from="(4480,270)" to="(4670,270)"/>
    <wire from="(4480,290)" to="(4510,290)"/>
    <wire from="(4480,310)" to="(4560,310)"/>
    <wire from="(4480,330)" to="(4500,330)"/>
    <wire from="(4500,330)" to="(4500,450)"/>
    <wire from="(4510,290)" to="(4510,330)"/>
    <wire from="(4510,330)" to="(4590,330)"/>
    <wire from="(4560,290)" to="(4560,310)"/>
    <wire from="(4560,290)" to="(4660,290)"/>
    <wire from="(4590,310)" to="(4590,330)"/>
    <wire from="(4590,310)" to="(4660,310)"/>
    <wire from="(4670,270)" to="(4670,280)"/>
    <wire from="(4690,300)" to="(4710,300)"/>
    <wire from="(4710,300)" to="(4710,470)"/>
    <wire from="(660,350)" to="(730,350)"/>
    <wire from="(680,200)" to="(1110,200)"/>
    <wire from="(680,200)" to="(680,480)"/>
    <wire from="(730,270)" to="(1070,270)"/>
    <wire from="(730,270)" to="(730,350)"/>
    <wire from="(730,350)" to="(730,530)"/>
    <wire from="(730,530)" to="(730,660)"/>
    <wire from="(730,660)" to="(750,660)"/>
    <wire from="(790,330)" to="(810,330)"/>
  </circuit>
  <vhdl name="ALU">library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.ALL;
use IEEE.std_logic_unsigned.ALL;

entity ALU is
    port(
    A, B       : in std_logic_vector(31 downto 0);   -- Operandos A e B de 32 bits da ALU
    controle   : in std_logic_vector(3 downto 0);    -- Entrada responsável por determinar a operação da ALU
    resultado  : out std_logic_vector(31 downto 0);  -- Resultado da operação feita pela ALU
    f_zero     : out std_logic;                      -- Flag indicadora de resultado igual a zero na operacão da ALU
    mode       : in std_logic;                       -- Modo de operação: 0 para operação única e 1 para operação vetorial
    vecSize     : in std_logic_vector(1 downto 0)     -- Tamanho do vetor de operações (usado no modo vetorial)
    );
end ALU;


architecture TypeArchitecture of ALU is

-- Declaração dos sinais temporários da ALU
signal resultado_nv : std_logic_vector(31 downto 0); -- Resultado não vetorial
signal resultado_v  : std_logic_vector(31 downto 0); -- Resultado vetorial
signal soma_v       : std_logic_vector(31 downto 0); -- Sinal temporário que armazena o resultado final da soma vetorial
signal sub_v        : std_logic_vector(31 downto 0); -- Sinal temporário que armazena o resultado final da subtração vetorial
signal shiftL_v     : std_logic_vector(31 downto 0); -- Sinal temporário que armazena o resultado final do Shift Left vetorial
signal shiftR_v     : std_logic_vector(31 downto 0); -- Sinal temporário que armazena o resultado final da Shift Right vetorial

signal A16_1 : std_logic_vector(15 downto 0);  -- Vetor que contém os bits de índice 31 até 16 do operando quando vecsize='10' (16 bits)
signal A16_2 : std_logic_vector(15 downto 0);  -- Vetor que contém os bits de índice 15 até 0 do operando quando vecsize='10' (16 bits)

signal A8_1 : std_logic_vector(7 downto 0);  -- Vetor que contém os bits de índice 31 até 24 do operando quando vecsize='01' (8 bits)
signal A8_2 : std_logic_vector(7 downto 0);  -- Vetor que contém os bits de índice 23 até 16 do operando quando vecsize='01' (8 bits)
signal A8_3 : std_logic_vector(7 downto 0);  -- Vetor que contém os bits de índice 15 até 8 do operando quando vecsize='01' (8 bits)
signal A8_4 : std_logic_vector(7 downto 0);  -- Vetor que contém os bits de índice 7 até 0 do operando quando vecsize='01' (8 bits)

signal A4_1 : std_logic_vector(3 downto 0);  -- Vetor que contém os bits de índice 31 até 28 do operando quando vecsize='00' (4 bits)
signal A4_2 : std_logic_vector(3 downto 0);  -- Vetor que contém os bits de índice 27 até 24 do operando quando vecsize='00' (4 bits)
signal A4_3 : std_logic_vector(3 downto 0);  -- Vetor que contém os bits de índice 23 até 20 do operando quando vecsize='00' (4 bits)
signal A4_4 : std_logic_vector(3 downto 0);  -- Vetor que contém os bits de índice 19 até 16 do operando quando vecsize='00' (4 bits)
signal A4_5 : std_logic_vector(3 downto 0);  -- Vetor que contém os bits de índice 15 até 12 do operando quando vecsize='00' (4 bits)
signal A4_6 : std_logic_vector(3 downto 0);  -- Vetor que contém os bits de índice 11 até 8 do operando quando vecsize='00' (4 bits)
signal A4_7 : std_logic_vector(3 downto 0);  -- Vetor que contém os bits de índice 7 até 4 do operando quando vecsize='00' (4 bits)
signal A4_8 : std_logic_vector(3 downto 0);  -- Vetor que contém os bits de índice 3 até 0 do operando quando vecsize='00' (4 bits)

signal integer_B : integer;                  -- Integer do valor binário que entra como operando B

begin

    -- Conversão da entrada B para integer para uso nas operações de deslocamento
    integer_B &lt;= to_integer(unsigned(B));

    -- Divisão do sinal de entrada A em subvetores para as operações vetoriais
    A16_1 &lt;= A(31 downto 16);
    A16_2 &lt;= A(15 downto 0);

    A8_1 &lt;= A(31 downto 24);
    A8_2 &lt;= A(23 downto 16);
    A8_3 &lt;= A(15 downto 8);
    A8_4 &lt;= A(7 downto 0);

    A4_1 &lt;= A(31 downto 28);
    A4_2 &lt;= A(27 downto 24);
    A4_3 &lt;= A(23 downto 20);
    A4_4 &lt;= A(19 downto 16);
    A4_5 &lt;= A(15 downto 12);
    A4_6 &lt;= A(11 downto 8);
    A4_7 &lt;= A(7 downto 4);
    A4_8 &lt;= A(3 downto 0);
    
    
    -- Cálculos das operações vetoriais com base no tamanho do vetor (vecsize)
    soma_v &lt;= (A + B) when vecSize = "11" else
             ((A16_1 + B(31 downto 16)) &amp; (A16_2 + B(15 downto 0))) when vecSize = "10" else
             ((A8_1 + B(31 downto 24)) &amp; (A8_2 + B(23 downto 16)) &amp; (A8_3 + B(15 downto 8)) &amp; (A8_4 + B(7 downto 0))) when vecSize = "01" else
             ((A4_1 + B(31 downto 28)) &amp; (A4_2 + B(27 downto 24)) &amp; (A4_3 + B(23 downto 20)) &amp; (A4_4 + B(19 downto 16)) &amp; (A4_5 + B(15 downto 12)) &amp; (A4_6 + B(11 downto 8)) &amp; (A4_7 + B(7 downto 4)) &amp; (A4_8 + B(3 downto 0))) when vecSize = "00";
    
    sub_v &lt;= (A - B) when vecSize = "11" else
             ((A16_1 - B(31 downto 16)) &amp; (A16_2 - B(15 downto 0))) when vecSize = "10" else
             ((A8_1 - B(31 downto 24)) &amp; (A8_2 - B(23 downto 16)) &amp; (A8_3 - B(15 downto 8)) &amp; (A8_4 - B(7 downto 0))) when vecSize = "01" else
             ((A4_1 - B(31 downto 28)) &amp; (A4_2 - B(27 downto 24)) &amp; (A4_3 - B(23 downto 20)) &amp; (A4_4 - B(19 downto 16)) &amp; (A4_5 - B(15 downto 12)) &amp; (A4_6 - B(11 downto 8)) &amp; (A4_7 - B(7 downto 4)) &amp; (A4_8 - B(3 downto 0))) when vecSize = "00";
    
    -- Cálculos das operações de deslocamento vetoriais
    shiftL_v &lt;= (std_logic_vector(shift_left(unsigned(A), integer_B))) when vecSize = "11" else
             ((std_logic_vector(shift_left(unsigned(A16_1), integer_B))) &amp; std_logic_vector(shift_left(unsigned(A16_2), integer_B))) when vecSize = "10" else
             ((std_logic_vector(shift_left(unsigned(A8_1), integer_B))) &amp; (std_logic_vector(shift_left(unsigned(A8_2), integer_B))) &amp; (std_logic_vector(shift_left(unsigned(A8_3), integer_B))) &amp; (std_logic_vector(shift_left(unsigned(A8_4), integer_B)))) when vecSize = "01" else
             ((std_logic_vector(shift_left(unsigned(A4_1), integer_B))) &amp; (std_logic_vector(shift_left(unsigned(A4_2), integer_B))) &amp; (std_logic_vector(shift_left(unsigned(A4_3), integer_B))) &amp; (std_logic_vector(shift_left(unsigned(A4_4), integer_B))) &amp; (std_logic_vector(shift_left(unsigned(A4_5), integer_B))) &amp; (std_logic_vector(shift_left(unsigned(A4_6), integer_B))) &amp; (std_logic_vector(shift_left(unsigned(A4_7), integer_B))) &amp; (std_logic_vector(shift_left(unsigned(A4_8), integer_B)))) when vecSize = "00";

    shiftR_v &lt;= (std_logic_vector(shift_right(unsigned(A), integer_B))) when vecSize = "11" else
             ((std_logic_vector(shift_right(unsigned(A16_1), integer_B))) &amp; std_logic_vector(shift_right(unsigned(A16_2), integer_B))) when vecSize = "10" else
             ((std_logic_vector(shift_right(unsigned(A8_1), integer_B))) &amp; (std_logic_vector(shift_right(unsigned(A8_2), integer_B))) &amp; (std_logic_vector(shift_right(unsigned(A8_3), integer_B))) &amp; (std_logic_vector(shift_right(unsigned(A8_4), integer_B)))) when vecSize = "01" else
             ((std_logic_vector(shift_right(unsigned(A4_1), integer_B))) &amp; (std_logic_vector(shift_right(unsigned(A4_2), integer_B))) &amp; (std_logic_vector(shift_right(unsigned(A4_3), integer_B))) &amp; (std_logic_vector(shift_right(unsigned(A4_4), integer_B))) &amp; (std_logic_vector(shift_right(unsigned(A4_5), integer_B))) &amp; (std_logic_vector(shift_right(unsigned(A4_6), integer_B))) &amp; (std_logic_vector(shift_right(unsigned(A4_7), integer_B))) &amp; (std_logic_vector(shift_right(unsigned(A4_8), integer_B)))) when vecSize = "00";
    

    -- ALU vetorial (mode = 1) 
    resultado_v &lt;= soma_v when controle = "0010" else
                sub_v when controle = "0110" else
                shiftL_v when controle = "0011" else
                shiftR_v when controle = "0111" else
                (others =&gt; '0');
    
    -- ALU não vetorial (mode = 0)
    resultado_nv &lt;= (A + B) when controle = "0010" else
                   (A - B) when controle = "0110" else
                   (A XOR B) when controle = "0101" else
                   (A OR B) when controle = "0001" else
                   (A AND B) when controle = "0000" else
                   (std_logic_vector(shift_left(unsigned(A), integer_B))) when controle = "0011" else
                   (std_logic_vector(shift_right(unsigned(A), integer_B))) when controle = "0111";
    
    -- Seleção do resultado de acordo com o sinal de controle "mode"
    resultado &lt;= resultado_nv when mode = '0' else
                resultado_v when mode = '1';
                
    -- Sinalização se o resultado é zero (serve para o Branch) -&gt; como as operações vetoriais não incluem Branch, basta verificar do resultado não vetorial
    f_zero &lt;= '1' when resultado_nv = "00000000000000000000000000000000" else '0';   

end TypeArchitecture;</vhdl>
  <vhdl name="ALU_Control">library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity ALU_Control is
    port(
        Funct7    		: IN std_logic_vector(6 downto 0);    	 -- Entrada do funct7
        Funct3    		: IN std_logic_vector(2 downto 0);    	 -- Entrada do funct3
        Opcode    		: IN std_logic_vector(6 downto 0);   	 -- Entrada do opcode
        AluOp   		: IN std_logic_vector(1 downto 0);       -- Entrada de códigos de operação da ALU (2 bits)
        ALU_Controle 	: OUT std_logic_vector(3 downto 0);      -- Saída do controle da ALU (4 bits)
        Beq_Bne		: OUT std_logic					 -- Sinal de controle para verificação de Beq ou Bne
        );
end ALU_Control;

architecture TypeArchitecture of ALU_Control is
begin

	ALU_Controle &lt;= "0010" when AluOp = "00" else 	-- Operação de Load
			 	 "0110" when AluOp = "01" else 	-- Operação de Branch
			 	 "0010" when Funct7 = "0000000" and Funct3 = "000" else 	-- Operação de Soma
			 	 "0110" when Funct7 = "0100000" and Funct3 = "000" else 	-- Operação de Subtração
			 	 "0011" when Funct7 = "0000000" and Funct3 = "001" else 	-- Operação de Shift Left
			 	 "0101" when Funct7 = "0000000" and Funct3 = "100" else 	-- Operação XOR
			 	 "0111" when Funct7 = "0000000" and Funct3 = "101" else 	-- Operação de Shift Right
			 	 "0001" when Funct7 = "0000000" and Funct3 = "110" else 	-- Operação OR
			 	 "0000" when Funct7 = "0000000" and Funct3 = "111"; 		-- Operação AND
	Beq_Bne &lt;= '1' when opcode="1100011" and Funct3="000" else '0';			-- '1' quando a instrução for Beq
	 
end TypeArchitecture;
</vhdl>
  <vhdl name="Control_Unit">library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity Control_Unit is
    port(
        instruction                	: IN  std_logic_vector(31 downto 0);  -- Entrada da Instrução
        Stall                			: IN  std_logic;  				   -- Entrada do Hazard
        AluSrc, RegWrite, MemToReg 	: OUT std_logic;                      -- Sinais de Controle (1 Bit)
        MemRead, MemWrite, Branch  	: OUT std_logic;                      -- Sinais de Controle (1 Bit)
        Soma_PC 					: OUT std_logic;			   	   -- Sinais de Controle (1 Bit)	
        AluOp		               	: OUT std_logic_vector(1 downto 0);   -- Saída da Operação da ALU (2 Bits)
        S_funct7 					: OUT std_logic_vector(6 downto 0);   -- Saída do Funct7
        S_funct3 					: OUT std_logic_vector(2 downto 0);   -- Saída do Funct3
        S_opcode 					: OUT std_logic_vector(6 downto 0);   -- Saída do Opcode
        JumpReg					: OUT std_logic;				   -- Indica quando a instrução é jalr	
        mode						: OUT std_logic;				   -- Indica se é uma operação vetorial
        Vecsize					: OUT std_logic_vector(1 downto 0));  -- Indica o tamanho do vetor
        
end Control_Unit;

architecture TypeArchitecture of Control_Unit is

signal opcode : std_logic_vector(6 downto 0);	-- Opcode da Instrução
signal funct7 : std_logic_vector(6 downto 0);	-- Funct7 da Instrução
signal funct3 : std_logic_vector(2 downto 0);	-- Funct3 da Instrução


begin
	-- Definição do Opcode da Instrução
	opcode(0) &lt;= instruction(0);
	opcode(1) &lt;= instruction(1);
	opcode(2) &lt;= instruction(2);
	opcode(3) &lt;= instruction(3);
	opcode(4) &lt;= instruction(4);
	opcode(5) &lt;= instruction(5);
	opcode(6) &lt;= instruction(6);
	Soma_PC &lt;= '0'; 
	JumpReg &lt;= '0';

	process(Stall)
	begin
		IF (Stall = '1') THEN
			AluSrc &lt;= '0';
			RegWrite &lt;= '0';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			Soma_PC &lt;= '0';
			JumpReg &lt;= '0';
		end if; 
	end process;
	-- Definição das Funct7, Funct3 e dos Sinais de Controle de acordo com o opcode.
	process(opcode)
	begin
		IF (opcode = "0110011") THEN		-- R-Type Instruction
			funct7(6) &lt;= instruction(31);
			funct7(5) &lt;= instruction(30);
			funct7(4) &lt;= instruction(29);
			funct7(3) &lt;= instruction(28);
			funct7(2) &lt;= instruction(27);
			funct7(1) &lt;= instruction(26);
			funct7(0) &lt;= instruction(25);
			funct3(2) &lt;= instruction (14);
			funct3(1) &lt;= instruction (13);
			funct3(0) &lt;= instruction (12);
			AluSrc &lt;= '0'; 			
			RegWrite &lt;= '1';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			mode &lt;= '0';
			Vecsize &lt;= "11";
			AluOp &lt;= "10";
		END IF;
		IF (opcode = "0010011") THEN		-- I-Type Instruction (ADDi, ANDi, ORi, XORi, SLTi)
			funct7(6) &lt;= '0';
			funct7(5) &lt;= '0';
			funct7(4) &lt;= '0';
			funct7(3) &lt;= '0';
			funct7(2) &lt;= '0';
			funct7(1) &lt;= '0';
			funct7(0) &lt;= '0';
			funct3(2) &lt;= instruction (14);
			funct3(1) &lt;= instruction (13);
			funct3(0) &lt;= instruction (12);
			AluSrc &lt;= '1'; 			
			RegWrite &lt;= '1';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			mode &lt;= '0';
			Vecsize &lt;= "11";
			AluOp &lt;= "10";
		END IF;
		IF (opcode = "0000011") THEN		-- I-Type Instruction (Load)
			funct7(6) &lt;= '0';
			funct7(5) &lt;= '0';
			funct7(4) &lt;= '0';
			funct7(3) &lt;= '0';
			funct7(2) &lt;= '0';
			funct7(1) &lt;= '0';
			funct7(0) &lt;= '0';
			funct3(2) &lt;= '0';
			funct3(1) &lt;= '0';
			funct3(0) &lt;= '0';
			AluSrc &lt;= '1'; 			
			RegWrite &lt;= '1';
			MemToReg &lt;= '1';
			MemRead &lt;= '1';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			mode &lt;= '0';
			Vecsize &lt;= "11";
			AluOp &lt;= "00";
		END IF;
		IF (opcode = "1100111") THEN		-- I-Type Instruction (Jump) 
			funct7(6) &lt;= '0';
			funct7(5) &lt;= '0';
			funct7(4) &lt;= '0';
			funct7(3) &lt;= '0';
			funct7(2) &lt;= '0';
			funct7(1) &lt;= '0';
			funct7(0) &lt;= '0';
			funct3(2) &lt;= '0';
			funct3(1) &lt;= '0';
			funct3(0) &lt;= '0';
			AluSrc &lt;= '0'; 			
			RegWrite &lt;= '0';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			Soma_PC &lt;= '1';
			JumpReg &lt;= '1';
			mode &lt;= '0';
			Vecsize &lt;= "11";
			AluOp &lt;= "01";
		END IF;
		IF (opcode = "0100011") THEN		-- S-Type Instruction 
			funct7(6) &lt;= '0';
			funct7(5) &lt;= '0';
			funct7(4) &lt;= '0';
			funct7(3) &lt;= '0';
			funct7(2) &lt;= '0';
			funct7(1) &lt;= '0';
			funct7(0) &lt;= '0';
			funct3(2) &lt;= '0';
			funct3(1) &lt;= '0';
			funct3(0) &lt;= '0';
			AluSrc &lt;= '1'; 			
			RegWrite &lt;= '0';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '1';
			Branch &lt;= '0';
			mode &lt;= '0';
			Vecsize &lt;= "11";
			AluOp &lt;= "00";
		END IF;
		IF (opcode = "1101111") THEN		-- UJ-Type Instruction (jal)
			funct7(6) &lt;= '0';
			funct7(5) &lt;= '0';
			funct7(4) &lt;= '0';
			funct7(3) &lt;= '0';
			funct7(2) &lt;= '0';
			funct7(1) &lt;= '0';
			funct7(0) &lt;= '0';
			funct3(2) &lt;= '0';
			funct3(1) &lt;= '0';
			funct3(0) &lt;= '0';
			AluSrc &lt;= '0'; 			
			RegWrite &lt;= '1';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			Soma_PC &lt;= '1';
			mode &lt;= '0';
			Vecsize &lt;= "11";
			AluOp &lt;= "10";
		END IF;
		IF (opcode = "0110111") THEN		-- U-Type Instruction (lui - soma com imediato muito grande)
			funct7(6) &lt;= '0';
			funct7(5) &lt;= '0';
			funct7(4) &lt;= '0';
			funct7(3) &lt;= '0';
			funct7(2) &lt;= '0';
			funct7(1) &lt;= '0';
			funct7(0) &lt;= '0';
			funct3(2) &lt;= '0';
			funct3(1) &lt;= '0';
			funct3(0) &lt;= '0';
			AluSrc &lt;= '1'; 			
			RegWrite &lt;= '1';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			mode &lt;= '0';
			Vecsize &lt;= "11";
			AluOp &lt;= "10";
		END IF;
		IF (opcode = "0010111") THEN		-- U-Type Instruction (auipc, soma do pc com o imediato e guarda no registrador)
			funct7(6) &lt;= '0';
			funct7(5) &lt;= '0';
			funct7(4) &lt;= '0';
			funct7(3) &lt;= '0';
			funct7(2) &lt;= '0';
			funct7(1) &lt;= '0';
			funct7(0) &lt;= '0';
			funct3(2) &lt;= '0';
			funct3(1) &lt;= '0';
			funct3(0) &lt;= '0';
			AluSrc &lt;= '1'; 			
			RegWrite &lt;= '1';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			Soma_PC &lt;= '1';
			mode &lt;= '0';
			Vecsize &lt;= "11";
			AluOp &lt;= "10";
		END IF;
		IF (opcode = "1100011") THEN		-- Sb-Type Instruction 
			funct7(6) &lt;= '0';
			funct7(5) &lt;= '0';
			funct7(4) &lt;= '0';
			funct7(3) &lt;= '0';
			funct7(2) &lt;= '0';
			funct7(1) &lt;= '0';
			funct7(0) &lt;= '0';
			funct3(2) &lt;= instruction (14);
			funct3(1) &lt;= instruction (13);
			funct3(0) &lt;= instruction (12);
			AluSrc &lt;= '0'; 			
			RegWrite &lt;= '0';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '1';
			mode &lt;= '0';
			Vecsize &lt;= "11";
			AluOp &lt;= "01";
		END IF;
		IF (opcode = "1111100") 	THEN		-- R-Type Vetorial Instruction (4bits)
			funct7(6) &lt;= instruction(31);
			funct7(5) &lt;= instruction(30);
			funct7(4) &lt;= instruction(29);
			funct7(3) &lt;= instruction(28);
			funct7(2) &lt;= instruction(27);
			funct7(1) &lt;= instruction(26);
			funct7(0) &lt;= instruction(25);
			funct3(2) &lt;= instruction (14);
			funct3(1) &lt;= instruction (13);
			funct3(0) &lt;= instruction (12);
			AluSrc &lt;= '0'; 			
			RegWrite &lt;= '1';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			mode &lt;= '1';
			Vecsize &lt;= "00";
			AluOp &lt;= "10";
		END IF;
		IF (opcode = "1111101")  THEN				-- R-Type Vetorial Instruction (8bits)
			funct7(6) &lt;= instruction(31);
			funct7(5) &lt;= instruction(30);
			funct7(4) &lt;= instruction(29);
			funct7(3) &lt;= instruction(28);
			funct7(2) &lt;= instruction(27);
			funct7(1) &lt;= instruction(26);
			funct7(0) &lt;= instruction(25);
			funct3(2) &lt;= instruction (14);
			funct3(1) &lt;= instruction (13);
			funct3(0) &lt;= instruction (12);
			AluSrc &lt;= '0'; 			
			RegWrite &lt;= '1';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			mode &lt;= '1';
			Vecsize &lt;= "01";
			AluOp &lt;= "10";
		END IF;
		IF (opcode = "1111110")	THEN			-- R-Type Vetorial Instruction (16bits)
			funct7(6) &lt;= instruction(31);
			funct7(5) &lt;= instruction(30);
			funct7(4) &lt;= instruction(29);
			funct7(3) &lt;= instruction(28);
			funct7(2) &lt;= instruction(27);
			funct7(1) &lt;= instruction(26);
			funct7(0) &lt;= instruction(25);
			funct3(2) &lt;= instruction (14);
			funct3(1) &lt;= instruction (13);
			funct3(0) &lt;= instruction (12);
			AluSrc &lt;= '0'; 			
			RegWrite &lt;= '1';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			mode &lt;= '1';
			Vecsize &lt;= "10";
			AluOp &lt;= "10";
		END IF;
		IF (opcode = "1111000") THEN		-- I-Type Vetorial Instruction (Soma e deslocamento)(4bits)
			funct7(6) &lt;= '0';
			funct7(5) &lt;= '0';
			funct7(4) &lt;= '0';
			funct7(3) &lt;= '0';
			funct7(2) &lt;= '0';
			funct7(1) &lt;= '0';
			funct7(0) &lt;= '0';
			funct3(2) &lt;= instruction (14);
			funct3(1) &lt;= instruction (13);
			funct3(0) &lt;= instruction (12);
			AluSrc &lt;= '1'; 			
			RegWrite &lt;= '1';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			mode &lt;= '1';
			Vecsize &lt;= "00";
			AluOp &lt;= "10";
		END IF;
		IF (opcode = "1111001") THEN		-- I-Type Vetorial Instruction (Soma e deslocamento)(8bits)
			funct7(6) &lt;= '0';
			funct7(5) &lt;= '0';
			funct7(4) &lt;= '0';
			funct7(3) &lt;= '0';
			funct7(2) &lt;= '0';
			funct7(1) &lt;= '0';
			funct7(0) &lt;= '0';
			funct3(2) &lt;= instruction (14);
			funct3(1) &lt;= instruction (13);
			funct3(0) &lt;= instruction (12);
			AluSrc &lt;= '1'; 			
			RegWrite &lt;= '1';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			mode &lt;= '1';
			Vecsize &lt;= "01";
			AluOp &lt;= "10";
		END IF;
		IF (opcode = "1111010") THEN		-- I-Type Vetorial Instruction (Soma e deslocamento)(16bits)
			funct7(6) &lt;= '0';
			funct7(5) &lt;= '0';
			funct7(4) &lt;= '0';
			funct7(3) &lt;= '0';
			funct7(2) &lt;= '0';
			funct7(1) &lt;= '0';
			funct7(0) &lt;= '0';
			funct3(2) &lt;= instruction (14);
			funct3(1) &lt;= instruction (13);
			funct3(0) &lt;= instruction (12);
			AluSrc &lt;= '1'; 			
			RegWrite &lt;= '1';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			mode &lt;= '1';
			Vecsize &lt;= "10";
			AluOp &lt;= "10";
		END IF;
		IF (opcode = "1110000") THEN		-- U-Type Vetorial Instruction (4bits)(auipc)
			funct7(6) &lt;= '0';
			funct7(5) &lt;= '0';
			funct7(4) &lt;= '0';
			funct7(3) &lt;= '0';
			funct7(2) &lt;= '0';
			funct7(1) &lt;= '0';
			funct7(0) &lt;= '0';
			funct3(2) &lt;= '0';
			funct3(1) &lt;= '0';
			funct3(0) &lt;= '0';
			AluSrc &lt;= '1'; 			
			RegWrite &lt;= '1';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			Soma_PC &lt;= '1';
			mode &lt;= '1';
			Vecsize &lt;= "00";
			AluOp &lt;= "10";
		END IF;
		IF (opcode = "1110001") THEN		-- U-Type Vetorial Instruction (4bits)(auipc)
			funct7(6) &lt;= '0';
			funct7(5) &lt;= '0';
			funct7(4) &lt;= '0';
			funct7(3) &lt;= '0';
			funct7(2) &lt;= '0';
			funct7(1) &lt;= '0';
			funct7(0) &lt;= '0';
			funct3(2) &lt;= '0';
			funct3(1) &lt;= '0';
			funct3(0) &lt;= '0';
			AluSrc &lt;= '1'; 			
			RegWrite &lt;= '1';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			Soma_PC &lt;= '1';
			mode &lt;= '1';
			Vecsize &lt;= "01";
			AluOp &lt;= "10";
		END IF;
		IF (opcode = "1110010") THEN		-- U-Type Vetorial Instruction (4bits)(auipc)
			funct7(6) &lt;= '0';
			funct7(5) &lt;= '0';
			funct7(4) &lt;= '0';
			funct7(3) &lt;= '0';
			funct7(2) &lt;= '0';
			funct7(1) &lt;= '0';
			funct7(0) &lt;= '0';
			funct3(2) &lt;= '0';
			funct3(1) &lt;= '0';
			funct3(0) &lt;= '0';
			AluSrc &lt;= '1'; 			
			RegWrite &lt;= '1';
			MemToReg &lt;= '0';
			MemRead &lt;= '0';
			MemWrite &lt;= '0';
			Branch &lt;= '0';
			Soma_PC &lt;= '1';
			mode &lt;= '1';
			Vecsize &lt;= "10";
			AluOp &lt;= "10";
		END IF;
	end process;
	S_funct7 &lt;= funct7;
	S_funct3 &lt;= funct3;
	S_opcode &lt;= opcode;
end TypeArchitecture;	</vhdl>
  <vhdl name="ImmGen">library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
USE IEEE.NUMERIC_STD.ALL;

entity ImmGen is
    Port( 
        instruction: in std_logic_vector(31 downto 0);  	-- Entrada da Instrução 
        immediate: out std_logic_vector(31 downto 0)  		-- Saída do Valor Imediato
        );
end ImmGen;

architecture Behavioral of ImmGen is
    signal opcode       : std_logic_vector(6 downto 0);  		-- Sinal para armazenr o opcode da instrução
    signal S_imm  : std_logic_vector(31 downto 0) := "00000000000000000000000000000000";  -- Sinal auxiliar para definição do imediato

begin

    opcode &lt;= instruction(6 downto 0);  -- Definição do opcode

    process(opcode)
    begin
        if (opcode = "0010011" or opcode = "0000011" or opcode = "1100111") then  	-- Tipo I 
            S_imm(11 downto 0)  &lt;= instruction(31 downto 20);  					-- Seleciona o imediato 
            S_imm(31 downto 12) &lt;= (others =&gt; instruction(31));  				-- Extensão do Bit de Sinal
        elsif (opcode = "1101111") then  									-- Tipo UJ 
            S_imm(20) &lt;= instruction(31);  									-- Seleciona o imediato
            S_imm(10 downto 1) &lt;= instruction(30 downto 21);					-- Seleciona o imediato
            S_imm(11) &lt;= instruction(20);									-- Seleciona o imediato	
            S_imm(19 downto 12) &lt;= instruction(19 downto 12);					-- Seleciona o imediato
            S_imm(31 downto 21) &lt;= (others =&gt; instruction(31));					-- Extensão do Bit de Sinal
        elsif (opcode = "0110111" or opcode = "0010111") then										-- Tipo U 
        	  S_imm(31 downto 12) &lt;= instruction(31 downto 12);  					-- Seleciona o imediato	
        elsif (opcode = "0100011") then  									-- Tipo S 
            S_imm(11 downto 5)  &lt;= instruction(31 downto 25);  					-- Seleciona o imediato
            S_imm(4 downto 0)   &lt;= instruction(11 downto 7);   					-- Seleciona o imediato
            S_imm(31 downto 12) &lt;= (others =&gt; instruction(31));  				-- Extensão do Bit de Sinal
        elsif (opcode = "1100011") then  									-- Tipo SB
            S_imm(12)           &lt;= instruction(31);          					-- Seleciona o imediato
            S_imm(11)           &lt;= instruction(7);           					-- Seleciona o imediato
            S_imm(10 downto 5)  &lt;= instruction(30 downto 25);  					-- Seleciona o imediato
            S_imm(4 downto 1)   &lt;= instruction(11 downto 8);   					-- Seleciona o imediato
            S_imm(31 downto 13) &lt;= (others =&gt; instruction(31));  				-- Extensão do Bit de Sinal
        end if;
    end process;

    immediate &lt;= S_imm;  												-- Atribui o valor imeadiato à saída

end Behavioral;
</vhdl>
  <vhdl name="PC4">library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use ieee.numeric_std.ALL;
use IEEE.std_logic_unsigned.ALL;


ENTITY PC4 IS
  PORT (
    CLK      : IN  std_logic;                    		-- Entrada do Clock
    RESET    : IN  std_logic;                    		-- Entrada de Reset
    PC_in    : IN  std_logic_vector(31 DOWNTO 0); 	-- Entrada do endereço atual
    WriteEnable   : IN std_logic;               		-- Entrada de Habilitação de escrita no PC
    PC_out   : OUT std_logic_vector(31 DOWNTO 0)  	-- Saída do próximo endereço
    );
END PC4;

ARCHITECTURE TypeArchitecture OF PC4 IS

BEGIN

	PROCESS (CLK, RESET, WriteEnable)
	BEGIN
		IF (rising_edge(CLK)) THEN                      				-- Detecção do Clock
			if (PC_in = "UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU") then   	-- Verificação de endereço indefinido
				PC_out &lt;= (others =&gt; '0');               			-- Caso indefinido, início no primeiro endereço
			elsif (WriteEnable = '0') then              				-- WriteEnable desabilitado
				PC_out &lt;= PC_in;								-- Manutenção do endereço atual
			elsif (WriteEnable = '1') then						-- WriteEnable habilitado
				PC_out &lt;= PC_in + '1';							-- Atualização do endereço
			end if;
		END IF;
		IF (RESET = '1') THEN                           				-- Detecção de Reset
			PC_out &lt;= (others =&gt; '0');                   			-- Retorno ao primeiro endereço
		END IF;
	END PROCESS;

END TypeArchitecture;
</vhdl>
  <vhdl name="Somador">LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE IEEE.std_logic_unsigned.ALL; 

ENTITY Somador IS
  PORT (
    A, B        : IN  std_logic_vector(31 DOWNTO 0); 	-- Entrada de vetores de 32 bits
    Z           : OUT std_logic_vector(31 DOWNTO 0) 	-- Saída do vetor resultado da soma
    );
END Somador;

ARCHITECTURE TypeArchitecture OF somador IS

BEGIN

Z &lt;= A + B; 									-- Vetor resultado da soma

END TypeArchitecture;
</vhdl>
  <vhdl name="RegisterFile">library ieee;
use ieee.std_logic_1164.all;
use ieee.numeric_std.all;

entity RegisterFile is
  port(
    ReadRegister_1           : in std_logic_vector(4 downto 0);    	-- Endereço do primeiro registrador a ser lido
    ReadRegister_2           : in std_logic_vector(4 downto 0);    	-- Endereço do segundo registrador a ser lido
    WriteRegister      	    : in std_logic_vector(4 downto 0);    	-- Endereço do registrador a ser escrito
    WriteData                : in  std_logic_vector(31 downto 0);     -- Dado a ser escrito
    RegWrite  			    : in  std_logic;     				-- Sinal de controle
    ReadData_1         	    : out  std_logic_vector(31 downto 0);    -- Dado do primeiro registrador lido
    ReadData_2       	    : out  std_logic_vector(31 downto 0);    -- Dado do segundo registrador lido
    CLK                 	    : in  std_logic                        	-- Sinal do CLOCK
    );
end RegisterFile;

architecture TypeArchitecture of RegisterFile is
  type RegisterFile is array(0 to 31) of std_logic_vector(31 downto 0);
  signal Registers : RegisterFile := 
   ("00000000000000000000000000000000","00000000000000000000000000000000","00000000000000000000000000000000","00000000000000000000000000000000",
    "00000000000000000000000000000000","00000000000000000000000000000000","00000000000000000000000000000000","00000000000000000000000000000000",
    "00000000000000000000000000000000","00000000000000000000000000000000","00000000000000000000000000000000","00000000000000000000000000000000",
    "00000000000000000000000000000000","00000000000000000000000000000000","00000000000000000000000000000000","00000000000000000000000000000000",
    "00000000000000000000000000000000","00000000000000000000000000000000","00000000000000000000000000000000","00000000000000000000000000000000",
    "00000000000000000000000000000000","00000000000000000000000000000000","00000000000000000000000000000000","00000000000000000000000000000000",
    "00000000000000000000000000000000","00000000000000000000000000000000","00000000000000000000000000000000","00000000000000000000000000000000",
    "00000000000000000000000000000000","00000000000000000000000000000000","00000000000000000000000000000000","00000000000000000000000000000000");

begin
  regFile : process (CLK) is
  begin
    if falling_edge(CLK) then
      if (Registers(to_integer(unsigned(ReadRegister_1))) = "UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU") THEN -- Caso o valor do registrador esteja indefinido, a saída será "000..."
      	ReadData_1 &lt;= (others =&gt; '0');  
      ELSE 
      	ReadData_1 &lt;= registers(to_integer(unsigned(ReadRegister_1)));  -- Leitura do valor contido no registrador 1
      END IF;
      IF (Registers(to_integer(unsigned(ReadRegister_2))) = "UUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU") THEN -- Caso o valor do registrador esteja indefinido, a saída será "000..."
      	ReadData_2 &lt;= (others =&gt; '0');  
      ELSE
      	ReadData_2 &lt;= registers(to_integer(unsigned(ReadRegister_2)));  -- Leitura do valor contido no registrador 2 
      END IF;
    end if; 
    if rising_edge(CLK) then
      if RegWrite = '1' then
        Registers(to_integer(unsigned(WriteRegister))) &lt;= WriteData;      -- Escrita do valor no registrador selecionado
      end if;
    end if;
  end process;
  
end TypeArchitecture;
</vhdl>
  <vhdl name="IFID">LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY IFID IS
  PORT (
    CLK         : IN  std_logic;                    -- Entrada do CLOCK
    PC_in        : IN  std_logic_vector(31 DOWNTO 0); -- Entrada do valor atual do PC (contador de programa)
    PC4_in	 : IN  std_logic_vector(31 downto 0); -- Entrada do valor do PC mais 4 (próxima instrução)
    WriteEnable   : IN std_logic;                 -- Entrada do sinal de habilitação de escrita no IFID
    Instruction_In      : IN  std_logic_vector(31 DOWNTO 0); -- Entrada da instrução atual buscada na memória de instruções
    PC_out       : OUT std_logic_vector(31 DOWNTO 0); -- Saída do valor atual do PC (contador de programa)
    PC4_out	 : OUT std_logic_vector(31 downto 0); -- Saída do valor do PC mais 4 (próxima instrução)
    Instruction_Out     : OUT std_logic_vector(31 DOWNTO 0);  -- Saída da instrução atual buscada na memória de instruções
    Rs1 : OUT std_logic_vector(4 DOWNTO 0);  -- Saída da instrução atual buscada na memória de instruções
    Rs2 : OUT std_logic_vector(4 DOWNTO 0);  -- Saída da instrução atual buscada na memória de instruções
    Rd : OUT std_logic_vector(4 DOWNTO 0)  -- Saída da instrução atual buscada na memória de instruções
    );
END IFID;


ARCHITECTURE TypeArchitecture OF IFID IS

signal opcode : std_logic_vector(6 downto 0);	-- Opcode da Instrução
signal s_Rs1 : std_logic_vector(4 downto 0);		-- Rs1 da Instrução
signal s_Rs2 : std_logic_vector(4 downto 0);		-- Rs2 da Instrução
signal s_Rd : std_logic_vector(4 downto 0);		-- Rd da Instrução
SIGNAL IDIF : std_logic_vector(117 DOWNTO 0);  	-- Registrador de 96 bits para armazenar os valores do IFID

BEGIN
	-- Definição do Opcode da Instrução
	opcode(0) &lt;= Instruction_In(0);
	opcode(1) &lt;= Instruction_In(1);
	opcode(2) &lt;= Instruction_In(2);
	opcode(3) &lt;= Instruction_In(3);
	opcode(4) &lt;= Instruction_In(4);
	opcode(5) &lt;= Instruction_In(5);
	opcode(6) &lt;= Instruction_In(6);

	process(opcode)
	begin
	-- Rs1
		IF NOT (opcode = "1101111" or opcode = "0110111") THEN  -- Tipos diferentes de U e UJ tem Rs1
		s_Rs1 (0) &lt;= Instruction_In(15);
		s_Rs1 (1) &lt;= Instruction_In(16);
		s_Rs1 (2) &lt;= Instruction_In(17);
		s_Rs1 (3) &lt;= Instruction_In(18);
		s_Rs1 (4) &lt;= Instruction_In(19);
		END IF;

	-- Rs2
		IF (opcode = "0110011" or opcode = "0100011" or opcode = "1100011") THEN  -- Tipos R, S e Sb tem Rs2
		s_Rs2 (0) &lt;= Instruction_In(20);
		s_Rs2 (1) &lt;= Instruction_In(21);
		s_Rs2 (2) &lt;= Instruction_In(22);
		s_Rs2 (3) &lt;= Instruction_In(23);
		s_Rs2 (4) &lt;= Instruction_In(24);
		END IF;

	-- Rd
		IF NOT (opcode = "0100011" or opcode = "1100011") THEN  -- Tipos diferentes de S e Sb tem Rd
		s_Rd (0) &lt;= Instruction_In(7); 
		s_Rd (1) &lt;= Instruction_In(8);
		s_Rd (2) &lt;= Instruction_In(9);
		s_Rd (3) &lt;= Instruction_In(10);
		s_Rd (4) &lt;= Instruction_In(11);
		END IF;
	end process;

	
	PROCESS (CLK, WriteEnable)
	BEGIN
		IF (rising_edge(CLK)) THEN                   	-- Detecção de subida de CLOCK
			if (WriteEnable = '1') then             	-- Vericação se o WriteEnable está habilitado
				IDIF(31 DOWNTO 0) &lt;= Instruction_In;       
				IDIF(63 DOWNTO 32) &lt;= PC_in;          	-- Armazena o valor atual do PC
				IDIF(95 downto 64) &lt;= PC4_in;       	-- Armazena o valor do PC mais 4 (próxima instrução)
				IDIF(102 downto 96) &lt;= opcode;		-- Armazena o opcode
				IDIF(107 downto 103) &lt;= s_Rs1;		-- Armazena o Rs1
				IDIF(112 downto 108) &lt;= s_Rs2;		-- Armazena o Rs2
				IDIF(117 downto 113) &lt;= s_Rd;			-- Armazena o Rd
			end if;
		END IF;
		IF (falling_edge(CLK)) THEN                 		-- Detecção de descida de CLOCK
			PC_out &lt;= IDIF(63 DOWNTO 32);           	-- Definição do PC atual
			Instruction_Out &lt;= IDIF(31 DOWNTO 0);        -- Definição da instrução armazenada
			PC4_out &lt;= IDIF(95 downto 64);        		-- Saída de PC+4
			Rs1 &lt;= IDIF(107 downto 103);				-- Saída do Rs1
			Rs2 &lt;= IDIF(112 downto 108);				-- Saída do Rs2
			Rd &lt;= IDIF(117 downto 113);				-- Saída do Rd
		END IF;
	END PROCESS;
	
END TypeArchitecture;
</vhdl>
  <vhdl name="IDEX">LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY IDEX IS
  PORT (
    CLK             : IN std_logic;                             -- Entrada do sinal de clock            
    ALUSrc_in       : IN std_logic;                             -- Entradas do ALUSrc e ALUOp, que são sinais de controle para a ALU_Control
    ALUOp_in        : IN std_logic_vector(1 downto 0);          -- ALUSrc e ALUOp são usados no estágio EX do pipeline, então não aparecem nos proximos regs do pipeline
    funct3_in       : IN std_logic_vector(2 downto 0);          -- Entrada do Funct3, usado na ALU_Control
    funct7_in       : IN std_logic_vector(6 downto 0);          -- Entrada do Funct7, usado na ALU_Control
    PC_in           : IN std_logic_vector(31 DOWNTO 0);         -- Entrada do valor atual do PC (contador de programa)
    Soma_PC_in      : IN std_logic;                             -- Entrada do sinal de controle que define quando o PC deve ser somado (jal)        
    Branch_in       : IN std_logic;                             -- Entrada do sinal de controle que define quando ocorre Branch
    MemWrite_in     : IN std_logic;                             -- Entrada do sinal de controle que define quando a Memória será escrita
    MemRead_in      : IN std_logic;                             -- Entrada do sinal de controle que define quando a Memória será lida
    RegWrite_in     : IN std_logic;                             -- Entrada do sinal de controle que define quando o registrador será escrito
    MemToReg_in     : IN std_logic;                             -- Entrada do sinal de controle que define quando um dado será passado da memória para o registrador
    read1_in        : IN std_logic_vector(31 DOWNTO 0);         -- Entrada do valor lido do read data 1
    read2_in        : IN std_logic_vector(31 DOWNTO 0);         -- Entrada do valor lido do read data 2
    immediate_in    : in std_logic_vector(31 DOWNTO 0);         -- Entrada do imediato gerado pelo ImmGen
    Rd_in           : IN std_logic_vector(4 DOWNTO 0);          -- Entrada da instrução atual buscada na memória de instruções
    Opcode_in       : IN std_logic_vector(6 DOWNTO 0);          -- Entrada do Opcode
    JumpReg_in      : IN std_Logic;                             -- Entrada do JumpReg
    Rs1_In          : IN std_logic_vector(4 downto 0);          -- Entrada do Rs1   
    Rs2_In          : IN std_logic_vector(4 downto 0);          -- Entrada do Rs2
    mode_in         : in std_logic;                             -- Modo de operação: 0 para operação única e 1 para operação vetorial
    vecsize_in      : in std_logic_vector(1 downto 0);          -- Tamanho do vetor de operações (usado no modo vetorial)
  
    ALUSrc_out      : out std_logic;                            -- Saídas do ALUSrc e ALUOp, que são sinais de controle para a ALU_Control
    ALUOp_out       : out std_logic_vector(1 downto 0);         -- ALUSrc e ALUOp são usados no estágio EX do pipeline, então não aparecem nos proximos regs do pipeline
    funct3_out      : out std_logic_vector(2 downto 0);         -- Saída do Funct3, usado na ALU_Control    
    funct7_out      : out std_logic_vector(6 downto 0);         -- Saída do Funct7, usado na ALU_Control
    PC_out          : out std_logic_vector(31 DOWNTO 0);        -- Saída do valor atual do PC (contador de programa)
    Soma_PC_out     : out std_logic;                            -- Saída do sinal de controle que define quando o PC deve ser somado (jal)
    Branch_out      : out std_logic;                            -- Saída do sinal de controle que define quando ocorre Branch
    MemWrite_out    : out std_logic;                            -- Saída do sinal de controle que define quando a Memória será escrita
    MemRead_out     : out std_logic;                            -- Saída do sinal de controle que define quando a Memória será lida
    RegWrite_out    : out std_logic;                            -- Saída do sinal de controle que define quando o registrador será escrito
    MemToReg_out    : out std_logic;                            -- Saída do sinal de controle que define quando um dado será passado da memória para o registrador
    read1_out       : out std_logic_vector(31 DOWNTO 0);        -- Saída do valor lido do read data 1
    read2_out       : out std_logic_vector(31 DOWNTO 0);        -- Saída do valor lido do read data 2   
    immediate_out   : out std_logic_vector(31 DOWNTO 0);        -- Saída do imediato gerado pelo ImmGen
    Rd_out          : out std_logic_vector(4 DOWNTO 0);         -- Saída da instrução atual buscada na memória de instruções
    Opcode_out      : out std_logic_vector(6 DOWNTO 0);         -- Saída do Opcode
    JumpReg_out     : out std_Logic;                            -- Saída do JumpReg
    Rs1_out         : out std_logic_vector(4 downto 0);         -- Saída do Rs1 
    Rs2_out         : out std_logic_vector(4 downto 0);          -- Saída do Rs2
    mode_out        : out std_logic;                            -- Modo de operação: 0 para operação única e 1 para operação vetorial
    vecsize_out     : out std_logic_vector(1 downto 0)          -- Tamanho do vetor de operações (usado no modo vetorial)
    );  
END IDEX;


ARCHITECTURE TypeArchitecture OF IDEX IS

SIGNAL idex_sig : std_logic_vector(173 DOWNTO 0);  -- Registrador de 151 bits para armazenar os valores do IDEX

BEGIN

    PROCESS (CLK)
    BEGIN
        IF (rising_edge(CLK)) THEN                   -- Detecção de subida de CLOCK
            idex_sig(0) &lt;= ALUSrc_in;          
            idex_sig(2 downto 1) &lt;= ALUOp_in;          
            idex_sig(5 DOWNTO 3) &lt;= funct3_in;      
            idex_sig(12 DOWNTO 6) &lt;= funct7_in;
            idex_sig(44 DOWNTO 13) &lt;= PC_in ;  
            idex_sig(45) &lt;= Soma_PC_in;       
            idex_sig(46) &lt;= Branch_in;   
            idex_sig(47) &lt;= MemWrite_in;   
            idex_sig(48) &lt;= MemRead_in;   
            idex_sig(49) &lt;= RegWrite_in;   
            idex_sig(50) &lt;= MemToReg_in;   
            idex_sig(82 DOWNTO 51) &lt;= read1_in;    
            idex_sig(114 DOWNTO 83) &lt;= read2_in;    
            idex_sig(146 DOWNTO 115) &lt;= immediate_in;   
            idex_sig(152 DOWNTO 147) &lt;= Rd_in;
            idex_sig(159 downto 153) &lt;= Opcode_in; 
            idex_sig(160) &lt;= JumpReg_in;  
            idex_sig(165 downto 161) &lt;= Rs1_In;
            idex_sig(170 downto 166) &lt;= Rs2_In;
            idex_sig(171) &lt;= mode_in;        
            idex_sig(173 downto 172) &lt;= vecsize_in;   
        END IF;
        IF (falling_edge(CLK)) THEN                 -- Detecção de descida de CLOCK
            ALUSrc_out &lt;= idex_sig(0);       
            ALUOp_out  &lt;= idex_sig(2 downto 1);     
            funct3_out &lt;= idex_sig(5 DOWNTO 3);      
            funct7_out &lt;= idex_sig(12 DOWNTO 6);    
            PC_out &lt;= idex_sig(44 DOWNTO 13);
            Soma_PC_out &lt;= idex_sig(45);
            Branch_out &lt;= idex_sig(46);
            MemWrite_out &lt;= idex_sig(47);
            MemRead_out &lt;= idex_sig(48);
            RegWrite_out &lt;= idex_sig(49);
            MemToReg_out &lt;= idex_sig(50);
            read1_out &lt;= idex_sig(82 DOWNTO 51);
            read2_out &lt;= idex_sig(114 DOWNTO 83);
            immediate_out &lt;= idex_sig(146 DOWNTO 115);
            Rd_out &lt;= idex_sig(152 DOWNTO 147);
            Opcode_out &lt;= idex_sig(159 downto 153);
            JumpReg_out &lt;= idex_sig(160);
            Rs1_out &lt;= idex_sig(165 downto 161);
            Rs2_out &lt;= idex_sig(170 downto 166);
            mode_out &lt;= idex_sig(171);
            vecsize_out &lt;= idex_sig(173 downto 172);
            
        END IF;
    END PROCESS;

    
END TypeArchitecture;</vhdl>
  <vhdl name="EXMEM">LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY EXMEM IS
  PORT (
    CLK             : IN std_logic;                             -- Entrada do sinal de clock            
    Branch_in       : IN std_logic;                             -- Entrada do sinal de controle que define quando ocorre Branch
    MemWrite_in     : IN std_logic;                             -- Entrada do sinal de controle que define quando a Memória será escrita
    MemRead_in      : IN std_logic;                             -- Entrada do sinal de controle que define quando a Memória será lida
    RegWrite_in     : IN std_logic;                             -- Entrada do sinal de controle que define quando o registrador será escrito
    MemToReg_in     : IN std_logic;                             -- Entrada do sinal de controle que define quando um dado será passado da memória para o registrador
    New_PC_in       : IN std_logic_vector(31 DOWNTO 0);         -- Soma do PC com imediato (jal) ou reg com imediato substituindo PC (jalr)
    Zero_in         : IN std_logic;                             -- Quando o resultado da ALU foi zero (serve para Branch)
    ALUresult_in    : IN std_logic_vector(31 DOWNTO 0);         -- Entrada do resultado da operação da ALU
    read2_in        : IN std_logic_vector(31 DOWNTO 0);         -- Entrada do valor lido do read data 2
    Rd_in           : IN std_logic_vector(4 DOWNTO 0);          -- Entrada da instrução atual buscada na memória de instruções
    Jalr_ou_Jal_in	: IN std_logic;					    -- Entrada que indica se é Jalr ou Jal	
  
    Branch_out      : out std_logic;                            -- Saída do sinal de controle que define quando ocorre Branch 
    MemWrite_out    : out std_logic;                            -- Saída do sinal de controle que define quando a Memória será escrita
    MemRead_out     : out std_logic;                            -- Saída do sinal de controle que define quando a Memória será lida
    RegWrite_out    : out std_logic;                            -- Saída do sinal de controle que define quando o registrador será escrito
    MemToReg_out    : out std_logic;                            -- Saída do sinal de controle que define quando um dado será passado da memória para o registrador
    New_PC_out       : out std_logic_vector(31 DOWNTO 0);        -- Soma do PC com imediato (jal) ou reg com imediato substituindo PC (jalr)
    Zero_out        : out std_logic;                            -- Quando o resultado da ALU foi zero (serve para Branch)
    ALUresult_out   : out std_logic_vector(31 DOWNTO 0);        -- Saída do resultado da operação da ALU
    read2_out       : out std_logic_vector(31 DOWNTO 0);        -- Saída do valor lido do read data 2
    Rd_out          : out std_logic_vector(4 DOWNTO 0);          -- Saída da instrução atual buscada na memória de instruções
    Jalr_ou_Jal_out	: out std_logic					    -- Saída que indica se é Jalr ou Jal
    );
END EXMEM;


ARCHITECTURE TypeArchitecture OF EXMEM IS

SIGNAL exmem_sig : std_logic_vector(107 DOWNTO 0);  -- Registrador de 192 bits para armazenar os valores do EXMEM

BEGIN

    PROCESS (CLK)
    BEGIN
        IF (rising_edge(CLK)) THEN                   -- Detecta a borda de subida do sinal de clock
            exmem_sig(0)    &lt;= Branch_in;          
            exmem_sig(1)    &lt;= MemWrite_in;          
            exmem_sig(2)   &lt;= MemRead_in;      
            exmem_sig(3)   &lt;= RegWrite_in;
            exmem_sig(4)   &lt;= MemToReg_in;  
            exmem_sig(36 downto 5)    &lt;= New_PC_in;       
            exmem_sig(37)           &lt;= Zero_in;   
            exmem_sig(69 downto 38)    &lt;= ALUresult_in;   
            exmem_sig(101 downto 70)    &lt;= read2_in;   
            exmem_sig(106 downto 102)    &lt;= Rd_in;   
            exmem_sig(107) &lt;= Jalr_ou_Jal_in;
        END IF;
        IF (falling_edge(CLK)) THEN                 -- Detecta a borda de descida do sinal de clock
            Branch_out    &lt;= exmem_sig(0);       
            MemWrite_out  &lt;= exmem_sig(1);     
            MemRead_out  &lt;= exmem_sig(2);      
            RegWrite_out &lt;= exmem_sig(3);    
            MemToReg_out &lt;= exmem_sig(4);
            New_PC_out &lt;= exmem_sig(36 downto 5);
            Zero_out &lt;= exmem_sig(37);
            ALUresult_out &lt;= exmem_sig(69 downto 38);
            read2_out &lt;= exmem_sig(101 downto 70);
            Rd_out &lt;= exmem_sig(106 downto 102);
            Jalr_ou_Jal_out &lt;= exmem_sig(107);
        END IF;
    END PROCESS;

    
END TypeArchitecture;</vhdl>
  <vhdl name="Hazard">library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity Hazard is 
    port( 
        clk                 : IN std_logic;                          -- Entrada do sinal de clock
        MemRead_in          : IN std_logic;                          -- Sinal de controle que define quando a Memória será lida
        Rd_EX               : IN std_logic_vector(4 downto 0);       -- Rd é o endereço de destino da operação feita pelo CPU após o estágio de EX
        Rs1, Rs2            : IN std_logic_vector(4 downto 0);       -- Rs1 e Rs2 são os endereços dos registradores contidos na instrução
        stall               : OUT std_logic                          -- Saída que indica se um "stall" (atraso) deve ser aplicado no pipeline
    );
end Hazard;

architecture Behavioral of Hazard is

    signal stall_interno : std_logic := '0';  -- Signal temporário que armazena o nível lógico do stall

begin
    process(clk)
    begin
        if ((MemRead_in = '1') and ((Rd_EX = Rs1) or (Rd_EX = Rs2))) then        -- Fórmula do livro, página 322
            stall_interno &lt;= '1';                                                -- Se o sinal de controle de MemRead_in for igual a 1 e o resultado  
        end if;                                                                  -- do estágio de Execution estiver em Rs1 ou Rs2, realiza um stall
    end process;

    stall &lt;= stall_interno;                                                     -- Atribui o valor do signal temporário stall_interno à saída stall

end Behavioral;</vhdl>
  <vhdl name="Forward">library IEEE;
use IEEE.STD_LOGIC_1164.ALL;

entity Forward is 
    port( 
         clk                        : IN std_logic;                         -- Entrada do sinal de clock
         regWrite_WB, regWrite_MEM  : IN std_logic;                         -- Sinais de controle de escrita no registrador do WB e do Mem, respectivamente
         Rs1, Rs2                   : IN std_logic_vector(4 downto 0);      -- Endereçoes dos registradores Rs1 e Rs2 vindos do estágio ID/EX do pipeline
         Rd_WB, Rd_Mem              : IN std_logic_vector(4 downto 0);      -- Endereços dos registradores de armazenamento Rd, vindos dos estágios de MEM/WB e EX/MEM do pipeline
         forwardA, forwardB         : OUT std_logic_vector(1 downto 0)      -- Saídas indicando os forwards para as fontes A e B
     );
end Forward;

ARCHITECTURE TypeArchitecture OF MEMWB IS
    signal forwardA_interno, forwardB_interno : std_logic_vector(1 downto 0) := "00";   -- Sinais internos que armazenam o encaminhamento

begin
    process(clk)
    begin
        if ((regWrite_MEM = '1') and (not(Rd_Mem = "00000")) and (Rd_Mem = Rs1)) then
            forwardA_interno &lt;= "10";   
        end if;

        if ((regWrite_MEM = '1') and (not(Rd_Mem = "00000")) and (Rd_Mem = Rs2)) then
            forwardB_interno &lt;= "10";  
        end if;

        if ((regWrite_WB = '1') and (not(Rd_WB = "00000")) and (Rd_WB = Rs1)) then
            forwardA_interno &lt;= "01";   
        end if;

        if ((regWrite_WB = '1') and (not(Rd_WB = "00000")) and (Rd_WB = Rs2)) then
            forwardB_interno &lt;= "01";   
        end if;

    end process;

    forwardA &lt;= forwardA_interno;  
    forwardB &lt;= forwardB_interno;
       
END TypeArchitecture;</vhdl>
  <vhdl name="MEMWB">LIBRARY ieee;
USE ieee.std_logic_1164.all;

ENTITY MEMWB IS
  PORT (
    CLK             : IN std_logic;                             -- Entrada do sinal de clock            
    RegWrite_in     : IN std_logic;                             -- Entrada do sinal de controle que define quando o registrador será escrito
    MemToReg_in     : IN std_logic;                             -- Entrada do sinal de controle que define quando um dado será passado da memória para o registrador
    Mem_data_in     : IN std_logic_vector(31 DOWNTO 0);         -- Entrada do valor lido na memória
    ALUresult_in    : IN std_logic_vector(31 DOWNTO 0);         -- Entrada do resultado da operação da ALU
    Rd_in           : IN std_logic_vector(4 DOWNTO 0);          -- Entrada da instrução atual buscada na memória de instruções
  
    RegWrite_out    : out std_logic;                            -- Saída do sinal de controle que define quando o registrador será escrito
    MemToReg_out    : out std_logic;                            -- Saída do sinal de controle que define quando um dado será passado da memória para o registrador
    Mem_data_out    : out std_logic_vector(31 DOWNTO 0);        -- Saída do valor lido na memória
    ALUresult_out   : out std_logic_vector(31 DOWNTO 0);        -- Saída do resultado da operação da ALU
    Rd_out          : out std_logic_vector(4 DOWNTO 0)          -- Saída da instrução atual buscada na memória de instruções
    );
END MEMWB;


ARCHITECTURE TypeArchitecture OF MEMWB IS

SIGNAL memwb_sig : std_logic_vector(70 DOWNTO 0);  -- Registrador de 70 bits para armazenar os valores do memwb

BEGIN

    PROCESS (CLK)
    BEGIN
        IF (rising_edge(CLK)) THEN                   -- Detecta a borda de subida do sinal de clock     
            memwb_sig(0)   &lt;= RegWrite_in;
            memwb_sig(1)   &lt;= MemToReg_in;  
            memwb_sig(33 downto 2)  &lt;= Mem_data_in ;       
            memwb_sig(65 downto 34)  &lt;= ALUresult_in;   
            memwb_sig(70 downto 66)  &lt;= Rd_in;   
        END IF;
        IF (falling_edge(CLK)) THEN                 -- Detecta a borda de descida do sinal de clock
            RegWrite_out &lt;= memwb_sig(0);    
            MemToReg_out &lt;= memwb_sig(1);
            Mem_data_out &lt;= memwb_sig(33 downto 2);
            ALUresult_out &lt;= memwb_sig(65 downto 34);
            Rd_out &lt;= memwb_sig(70 downto 66);
        END IF;
    END PROCESS;

    
END TypeArchitecture;</vhdl>
</project>
